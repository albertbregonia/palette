// Palette Â© Albert Bregonia 2021
package main

import (
	"encoding/json"
	"net/http"
	"sync"

	"github.com/gorilla/websocket"
	"github.com/pion/webrtc/v3"
)

var (
	wsUpgrader = websocket.Upgrader{
		ReadBufferSize:  512,
		WriteBufferSize: 512,
		CheckOrigin: func(r *http.Request) bool {
			_, lobby, _ := ParseSession(nil, r)
			return lobby != nil //if the websocket connection is from a valid user in a lobby
		},
	}
	config = webrtc.Configuration{
		ICEServers: []webrtc.ICEServer{{URLs: []string{`stun:stun.l.google.com:19302`}}},
	}
)

//SignalingSocket is a thread safe WebSocket used only for establishing WebRTC connections
type SignalingSocket struct {
	*websocket.Conn
	sync.Mutex
}

//SendSignal is a thread safe wrapper for the `websocket.WriteJSON()` function that only sends the JSON form of a `Signal` struct
func (signaler *SignalingSocket) SendSignal(s Signal) error {
	signaler.Lock()
	defer signaler.Unlock()
	return signaler.WriteJSON(s)
}

//Signals to be written on a SignalingSocket in order to establish WebRTC connections
type Signal struct {
	Event string `json:"event"`
	Data  string `json:"data"`
}

func SignalingServer(w http.ResponseWriter, r *http.Request) {
	//create a thread safe websocket for signaling with JavaScript
	ws, e := wsUpgrader.Upgrade(w, r, nil)
	if e != nil {
		http.Error(w, e.Error(), http.StatusBadRequest)
	}
	signaler := SignalingSocket{ws, sync.Mutex{}}
	defer signaler.Close()

	//create the WebRTC peer connection that will broadcast lobby events, chat and whiteboard data
	peer, e := webrtc.NewPeerConnection(config)
	if e != nil {
		return
	}
	notTrue := false //create data channel to stream whiteboard data to users in the lobby
	channel, e := peer.CreateDataChannel(`whiteboard`, &webrtc.DataChannelInit{Ordered: &notTrue})
	if e != nil {
		return
	}
	channel.OnMessage(func(msg webrtc.DataChannelMessage) {}) //todo: parse data and forward to lobby channel

	peer.OnICECandidate(func(ice *webrtc.ICECandidate) {
		if ice == nil {
			return
		}
		iceJS, _ := json.Marshal(ice.ToJSON()) //error is ignored as the struct is generated by WebRTC
		if e := signaler.SendSignal(Signal{`ice`, string(iceJS)}); e != nil {
			signaler.Close()
		}
	})

	offer, e := peer.CreateOffer(nil) //send offer to frontend
	if e != nil {
		return
	}
	if e := peer.SetLocalDescription(offer); e != nil {
		return
	}
	offerJS, _ := json.Marshal(offer)
	if e = signaler.SendSignal(Signal{`offer`, string(offerJS)}); e != nil {
		return
	}
	signal := Signal{}
	for {
		if e := signaler.ReadJSON(&signal); e != nil {
			return
		}
		switch signal.Event {
		case `ice`:
			candidate := webrtc.ICECandidateInit{}
			if e := json.Unmarshal([]byte(signal.Data), &candidate); e != nil {
				return
			}
			if e := peer.AddICECandidate(candidate); e != nil {
				return
			}
		case `answer`:
			answer := webrtc.SessionDescription{}
			if e := json.Unmarshal([]byte(signal.Data), &answer); e != nil {
				return
			}
			if e := peer.SetRemoteDescription(answer); e != nil {
				return
			}
		}
	}
}
